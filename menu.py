#GeometryDashAccountInformation
from colorama import init
init()
from colorama import Fore, Back, Style
import geometrydashapi as gdapi
import gd
import pyfiglet
import os
import time
client = gd.Client()
result = pyfiglet.figlet_format("GD Info Tool v1.0", font = "big")
print(Fore.GREEN + result + Style.RESET_ALL)
time.sleep(2)
print(Back.RED + "ВНИМАНИЕ: ДЛЯ ПОЛУЧЕНИЯ ИНФОРМАЦИИ О АККАУНТЕ СЛЕДУЕТ ПЕРЕЙТИ В ПУНКТ 3 И ПОЛУЧИТЬ ID АККАУНТА, А ЗАТЕМ УЖЕ ОТКРЫВАЙТЕ ПУНКТ 1 ДЛЯ ПОЛУЧЕНИЯ ИНФОРМАЦИИ!" + Style.RESET_ALL)
time.sleep(0.2)
restart = True
while restart:
        print("Пожалуйста, выберете один из перечисленных вариантов:")
        time.sleep(0.5)
        print("1 - Информация о аккаунте")
        time.sleep(0.2)
        print("2 - Информация о музыке")
        time.sleep(0.2)
        print("3 - Получение Account ID", Back.RED + "ВРЕМЕННО!" + Style.RESET_ALL)
        time.sleep(0.2)
        print("4 - Информация о уровне")
        time.sleep(0.2)
        print("5 - Получение данных уровня")
        time.sleep(0.2)
        print("6 - Об авторе")
        a = int(input("Выберите пункт: "))
        if (a == 1):
            print("Выбрано меню информации об аккаунте!")
            time.sleep(1)
            os.system('CLS')
            c = int(input("Введите Account ID: "))
            async def test():
                user = await client.get_user(c)
                os.system('CLS')
                print("Имя игрока: ",user.name)
                time.sleep(0.2)
                print("ID: ",user.account_id)
                time.sleep(0.2)
                print("Звезды: ",user.stars)
                time.sleep(0.2)
                print("Алмазы: ",user.diamonds)
                time.sleep(0.2)
                print("Официальные монеты: ",user.coins)
                time.sleep(0.2)
                print("Пользовательские монеты: ",user.user_coins)
                time.sleep(0.2)
                print("Демоны: ",user.demons)
                time.sleep(0.2)
                print("Twitch: ",user.twitch_link)
                time.sleep(0.2)
                print("YouTube: ",user.youtube_link)
                time.sleep(0.2)
                print("Twitter: ",user.twitter_link)
                time.sleep(0.2)
                print("Строительные очки: ",user.cp)
                time.sleep(0.2)
                print("Место в таблице лидеров: ",user.place)
                time.sleep(0.2)
                print("Привилегия: ",user.role)
                time.sleep(0.2)
                print("Глобальный ранг: ",user.rank)
                time.sleep(0.2)
                print("Можно ли писать сообщения?: ",user.message_policy)
                time.sleep(0.2)
                print("Можно ли отправлять запрос в друзья?: ",user.friend_request_policy)
                time.sleep(0.2)
                print("Цвет иконок: ",user.icon_set)
                time.sleep(0.2)
            client.run(test())
            input(Back.GREEN + "Нажмите для возвращения в меню" + Style.RESET_ALL)
            os.system('CLS')
        elif (a == 2):
            print("Выбрано меню информации об музыке!")
            time.sleep(1)
            os.system('CLS')
            b = int(input("Введи ID музыки: "))
            async def music():
                song = await client.get_song(b)
                os.system('CLS')
                print("Информация о музыке:")
                time.sleep(0.2)
                print("Автор: ", song.author)
                time.sleep(0.2)
                print("Название: ", song.name)
                time.sleep(0.2)
                print("Размер файла: ", song.size)
                time.sleep(0.2)
                print("Ссылка на музыку: ", song.link)
                time.sleep(0.2)
                print("Скачать: ", song.dl_link)
                time.sleep(0.2)
            client.run(music())
            input(Back.GREEN + "Нажмите для возвращения в меню" + Style.RESET_ALL)
            os.system('CLS')
        elif (a == 3):
            print("Выбрано меню получения Account ID!")
            time.sleep(1)
            os.system('CLS')
            c = input("Введите никнейм: ")
            time.sleep(0.2)
            print("ID Игрока: ",gdapi.user(c)["playerID"])
            time.sleep(0.2)
            print("ID Аккаунта: ",gdapi.user(c)["accountID"] , Back.RED + "ИСПОЛЬЗУЙТЕ В ПУНКТЕ 1" + Style.RESET_ALL)
            input(Back.GREEN + "Нажмите для возвращения в меню" + Style.RESET_ALL)
            os.system('CLS')
        elif (a == 4):
            print("Выбрано меню получения информации об уровне!")
            time.sleep(0.2)
            os.system('CLS')
            d = int(input("Введите ID уровня: "))
            async def level():
                level = await client.get_level(d)
                os.system('CLS')
                print("Информация о уровне:")
                time.sleep(1)
                print("Имя: ", level.name)
                time.sleep(0.2)
                print("Создатель: ", level.creator)
                time.sleep(0.2)
                print("Описание: ", level.description)
                time.sleep(0.2)
                print("Версия: ", level.version)
                time.sleep(0.2)
                print("Загружен: ", level.downloads)
                time.sleep(0.2)
                print("Лайки: ", level.rating)
                time.sleep(0.2)
                print("Имеет 'Featured'?: ", level.score)
                time.sleep(0.2)
                print("Музыка: ", level.song)
                time.sleep(0.2)
                print("Сложность уровня: ", level.difficulty)
                time.sleep(0.2)
                print("Пароль: ", level.password)
                time.sleep(0.2)
                print("Звезды: ", level.stars)
                time.sleep(0.2)
                print("Монеты: ", level.coins)
                time.sleep(0.2)
                print("Оригинальный ID: ", level.original_id)
                time.sleep(0.2)
                print("Впервые был выложен на сервер: ", level.uploaded_timestamp, "ago")
                time.sleep(0.2)
                print("Последнее обновление уровня: ", level.last_updated_timestamp, "ago")
                time.sleep(0.2)
                print("Длина уровня: ", level.length)
                time.sleep(0.2)
                print("Версия игры, в которой был выложен уровень: ", level.game_version)
                time.sleep(0.2)
                print("Сколько звезд отправили: ", level.requested_stars)
                time.sleep(0.2)
                print("Число обьектов: ", level.objects)
                time.sleep(0.2)
                print("Число обьектов(сервер): ", level.object_count)
                time.sleep(0.2)
                print("Был ли уровень в Ежедневных/Недельных уровнях?: ", level.type)
                time.sleep(0.2)
            client.run(level())
            input(Back.GREEN + "Нажмите для возвращения в меню" + Style.RESET_ALL)
            os.system('CLS')
        elif (a == 5):
            async def data():
                print("Выбрано меню получения данных уровня!")
                time.sleep(1)
                os.system('CLS')
                print(Back.RED + "Эта функция для опытных пользователей! Данная функция запрашивает все данные об содержимом уровня (блоки, обьекты и т.д...) Крайне не рекомендую вписывать уровни с большим количеством обьектов! Я предупредил)" + Style.RESET_ALL)
                e = int(input("Введите ID уровня: "))
                level = await client.get_level(e)
                print(level.data)
            client.run(data())
            input(Back.GREEN + "Нажмите для возвращения в меню" + Style.RESET_ALL)
            os.system('CLS')
        elif (a == 6):
            print("Сделал скрипт: dezz0xy (git: xtr-root)")
            print("Социальные сети автора:")
            print(Back.YELLOW + " - VK: https://vk.com/stell_dj")
            print(Back.YELLOW + " - YT: https://www.youtube.com/channel/UC9OzfUH3TRhkxNdPBPQz_NQ")
SystemExit(0)


# тебе сюда нельзя, выйди
    
